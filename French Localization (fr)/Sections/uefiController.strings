
/* Class = "NSButtonCell"; title = "AppleImageConversion"; ObjectID = "0AM-nb-Yrd"; */
"0AM-nb-Yrd.title" = "AppleImageConversion";

/* Class = "NSTextFieldCell"; title = "PointerSpeedMul"; ObjectID = "0MH-zm-tw2"; */
"0MH-zm-tw2.title" = "PointerSpeedMul";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces Apple audio protocols with builtin versions.\n\nApple audio protocols allow OpenCore and the macOS bootloader to play sounds and signals for screen reading or audible error reporting. Supported protocols are beep generation and VoiceOver. The VoiceOver protocol is specific to Gibraltar machines (T2) and is not supported before macOS High Sierra (10.13). Older macOS versions use the AppleHDA protocol (which is not currently implemented) instead.\n\nOnly one set of audio protocols can be available at a time, so this setting should be enabled in order to enable audio playback in the OpenCore user interface on Mac systems implementing some of these protocols.\n\nNote: The backend audio driver needs to be configured in UEFI Audio section for these protocols to be able to stream audio."; ObjectID = "0RZ-LX-aI2"; */
"0RZ-LX-aI2.ibShadowedToolTip" = "Réinstallez Apple Audio Protocol avec la version intégrée. \n Le protocole audio Apple permet au chargeur de démarrage macOS et à OpenCore de lire des sons et des signaux pour la lecture d'écran ou le signalement des erreurs sonores. \n Les protocoles pris en charge sont la génération de bips et VoiceOver. Non pris en charge avant macOS High Sierra (10.13). En revanche, les versions antérieures de macOS utilisaient le protocole AppleHDA, qui n'est pas actuellement implémenté. \n  \n Pour obtenir la lecture audio dans l'interface utilisateur OpenCore sur les systèmes Mac qui implémentent certains protocoles, ce paramètre doit être activé. \n  \n Remarque: vous devez configurer le pilote audio principal dans la section UEFI-> Audio pour que ces protocoles fonctionnent.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: NO\nDescription: Some types of firmware (such as APTIO IV) may contain invalid values in the MSR_FLEX_RATIO (0x194) MSR register. These values may cause macOS boot failures on Intel platforms.\n\nNote: While the option is not expected to harm unaffected firmware, its use is recommended only when specifically required."; ObjectID = "0Sc-nS-2YL"; */
"0Sc-nS-2YL.ibShadowedToolTip" = "Si vous n'avez pas déverrouillé CFG dans le bios, assurez-vous de sélectionner OUI.";

/* Class = "NSTextFieldCell"; title = "AudioDevice"; ObjectID = "0gM-HU-fz5"; */
"0gM-HU-fz5.title" = "AudioDevice";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Attempts to perform TSC synchronisation with a specified timeout.\n\nThe primary purpose of this quirk is to enable early bootstrap TSC synchronisation on some server and laptop models when running a debug XNU kernel. For the debug kernel the TSC needs to be kept in sync across the cores before any kext could kick in rendering all other solutions problematic. The timeout is specified in microseconds and depends on the amount of cores present on the platform, the recommended starting value is 500000.\n\nThis is an experimental quirk, which should only be used for the aforementioned problem. In all other cases the quirk may render the operating system unstable and is not recommended. The recommended solution in the other cases is to install a kernel driver such as VoodooTSCSync, TSCAdjustReset, or CpuTscSync (a more specialised variant of VoodooTSCSync for newer laptops).\n\nNote: This quirk cannot replace the kernel driver because it cannot operate in ACPI S3 (sleep wake) mode and because the UEFI firmware only provides very limited multicore support which prevents precise updates of the MSR registers."; ObjectID = "0un-PF-SFE"; */
"0un-PF-SFE.ibShadowedToolTip" = "Type: entier plist \nFailsafe: 0 \nDescription: tente d'effectuer la synchronisation TSC avec un délai spécifié. \nLe but principal de cette bizarrerie est d'activer la synchronisation TSC bootstrap précoce sur certains modèles de serveur et d'ordinateur portable lors de l'exécution d'un noyau de débogage XNU. Pour le noyau de débogage, le TSC doit être synchronisé entre les cœurs avant que n'importe quel kext ne puisse rendre problématique toutes les autres solutions. Le délai d'expiration est spécifié en microsecondes et dépend de la quantité de cœurs présents sur la plate-forme, la valeur de départ recommandée est 500000. \nCeci est une bizarrerie expérimentale, qui ne devrait être utilisée que pour le problème susmentionné. Dans tous les autres cas, la bizarrerie peut rendre le système d'exploitation instable et n'est pas recommandée. La solution recommandée dans les autres cas consiste à installer un pilote de noyau comme VoodooTSCSync, TSCAdjustReset ou CpuTscSync (une variante plus spécialisée de VoodooTSCSync pour les ordinateurs portables plus récents). \n \nRemarque: la raison pour laquelle cette bizarrerie ne peut pas remplacer le pilote du noyau est parce qu'elle ne peut pas fonctionner en mode ACPI S3 (veille de veille) et parce que les firmwares UEFI fournissent un support multicœur très limité empêchant la mise à jour précise des registres MSR.";

/* Class = "NSButtonCell"; title = "EnableJumpstart"; ObjectID = "133-jD-qYy"; */
"133-jD-qYy.title" = "EnableJumpstart";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reconnect console controllers after changing screen resolution.\n\nOn certain firmware, the controllers that produce the console protocols (simple text out) must be reconnected when the screen resolution is changed via GOP. Otherwise, they will not produce text based on the new resolution.\n\nNote: On several boards this logic may result in black screen when launching OpenCore from Shell and thus it is optional. In versions prior to 0.5.2 this option was mandatory and not configurable. Please do not use this unless required."; ObjectID = "1QT-lu-i79"; */
"1QT-lu-i79.ibShadowedToolTip" = "Certains micrologiciels nécessitent de reconnecter le contrôleur pour afficher le texte après la modification de la résolution GOP. L'activation de cette option entraînera la disparition de l'écran lors du démarrage d'OpenCore à partir du shell UEFI. \n Si vous rencontrez un écran noir jusqu'à l'écran de connexion, veuillez essayer de sélectionner OUI.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable AVX vector acceleration of SHA-512 and SHA-384 hashing algorithms."; ObjectID = "2Bt-b4-cNE"; */
"2Bt-b4-cNE.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Enable AVX vector acceleration of SHA-512 and SHA-384 hashing algorithms.";

/* Class = "NSButtonCell"; title = "ForceResolution"; ObjectID = "2kV-J6-o4B"; */
"2kV-J6-o4B.title" = "ForceResolution";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Activate audio support by connecting to a backend driver.\n\nEnabling this setting routes audio playback from builtin protocols to a dedicated audio port (AudioOut) of the specified codec (AudioCodec) located on the audio controller (AudioDevice)."; ObjectID = "2zI-kW-5dk"; */
"2zI-kW-5dk.ibShadowedToolTip" = "Activez la prise en charge audio en vous connectant à un pilote principal (vous devez ajouter le pilote AudioDxe.efi). \n  \n Activez ce paramètre pour router la lecture audio du protocole intégré vers le port audio dédié (AudioOut) du codec spécifié (AudioCodec) situé sur le contrôleur audio (AudioDevice).";

/* Class = "NSButtonCell"; title = "HashServices"; ObjectID = "33a-jy-EES"; */
"33a-jy-EES.title" = "HashServices";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Request redirect of all Boot prefixed variables from EFI_GLOBAL_VARIABLE_GUID to OC_VENDOR_VARIABLE_GUID.\n\nThis quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi. The quirk lets default boot entry preservation at times when the firmware deletes incompatible boot entries. In summary, this quirk is required to reliably use the Startup Disk preference pane in firmware that is not compatible with macOS boot entries by design.\n\nBy redirecting Boot prefixed variables to a separate GUID namespace with the help of RequestBootVarRouting quirk we achieve multiple goals:\n• Operating systems are jailed and only controlled by OpenCore boot environment to enhance security.\n• Operating systems do not mess with OpenCore boot priority, and guarantee fluent updates and hibernation wakes for cases that require reboots with OpenCore in the middle.\n• Potentially incompatible boot entries, such as macOS entries, are not deleted or corrupted in any way."; ObjectID = "3Q0-sm-ooL"; */
"3Q0-sm-ooL.ibShadowedToolTip" = "Activez cette option pour permettre une utilisation fiable du paramètre [disque de démarrage] dans le micrologiciel qui n'est pas compatible avec la conception d'entrée de démarrage macOS. \n Il est également lié à la mémorisation de la fonction d'entrée de démarrage par défaut, il est recommandé d'utiliser OUI";

/* Class = "NSTextFieldCell"; title = "TimerResolution"; ObjectID = "3Ql-TM-Oiv"; */
"3Ql-TM-Oiv.title" = "TimerResolution";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty\nDescription: Set OEM protocol used for internal pointer driver.\nCurrently the only supported variant is ASUS, using specialised protocol available on certain Z87 and Z97 ASUS boards. The value of this property cannot be empty if PointerSupport is enabled."; ObjectID = "3mi-sh-qNa"; */
"3mi-sh-qNa.ibShadowedToolTip" = "Généralement laissé vide \n Il utilise certains protocoles propriétaires disponibles sur les cartes ASUS Z87 et Z97.";

/* Class = "NSButtonCell"; title = "RequestBootVarRouting"; ObjectID = "4Eq-ma-JKy"; */
"4Eq-ma-JKy.title" = "RequestBootVarRouting";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces unicode collation services with builtin versions. Set to true to ensure UEFI Shell compatibility on platforms with defective unicode collation implementations. Legacy Insyde and APTIO platforms on Ivy Bridge, and earlier, are typically affected."; ObjectID = "4bg-ao-G40"; */
"4bg-ao-G40.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Certains firmwares plus anciens rompent le classement Unicode. Le réglage sur YES peut corriger la compatibilité du shell UEFI sur ces systèmes (généralement pour IvyBridge ou des appareils plus anciens) ";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal keyboard input translation to AppleKeyMapAggregator protocol.\n\nThis option activates the internal keyboard interceptor driver, based on AppleGenericInput, also known as AptioInputFix, to fill the AppleKeyMapAggregator database for input functioning. In cases where a separate driver such as OpenUsbKbDxe is used, this option should never be enabled. Additionally, this option is not required and should not be enabled with Apple firmware."; ObjectID = "4fK-xq-9AN"; */
"4fK-xq-9AN.ibShadowedToolTip" = "Activez la prise en charge du clavier intégré d'OC. Certains ordinateurs portables ne peuvent pas utiliser le clavier dans l'interface du menu de démarrage. Veuillez le sélectionner! \n Si vous utilisez AppleUsbKbdxe.efi, veuillez définir NON";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Set HDA Traffic Class Select Register to TC0.\n\nAppleHDA kext will function correctly only if TCSEL register is configured to use TC0 traffic class. Refer to Intel I/O Controller Hub 9 (ICH9) Family Datasheet (or any other ICH datasheet) for more details about this register.\n\nNote: This option is independent from AudioSupport. If AppleALC is used it is preferred to use AppleALC alctsel property instead."; ObjectID = "4mo-Ut-bYl"; */
"4mo-Ut-bYl.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Set HDA Traffic Class Select Register to TC0.\n\nAppleHDA kext will function correctly only if TCSEL register is configured to use TC0 traffic class. Refer to Intel I/O Controller Hub 9 (ICH9) Family Datasheet (or any other ICH datasheet) for more details about this register.\n\nNote: This option is independent from AudioSupport. If AppleALC is used it is preferred to use AppleALC alctsel property instead.";

/* Class = "NSTabViewItem"; label = "Audio"; ObjectID = "5Gm-fv-IpR"; */
"5Gm-fv-IpR.label" = "Audio";

/* Class = "NSTextFieldCell"; title = "CustomDelays"; ObjectID = "5zT-C9-V64"; */
"5zT-C9-V64.title" = "CustomDelays";

/* Class = "NSButtonCell"; title = "EnableVectorAcceleration"; ObjectID = "63M-Ew-u4v"; */
"63M-Ew-u4v.title" = "EnableVectorAcceleration";

/* Class = "NSButtonCell"; title = "JumpstartHotPlug"; ObjectID = "6B4-NA-lHR"; */
"6B4-NA-lHR.title" = "JumpstartHotPlug";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "6k6-uj-n97"; */
"6k6-uj-n97.headerCell.title" = "Commentaire";

/* Class = "NSTableView"; ibShadowedToolTip = "Type: plist array\nFailsafe: None\nDescription: Load selected drivers from OC/Drivers directory.\nDesigned to be filled with string filenames meant to be loaded as UEFI drivers. Depending on the firmware a different set of drivers may be required. Loading an incompatible driver may lead your system to unbootable state or even cause permanent firmware damage. Some of the known drivers include:\n• AudioDxe — HDA audio support driver in UEFI firmwares for most Intel and some other analog audio controllers.\n• CrScreenshotDxe — Screenshot making driver saving images to the root of OpenCore partition (ESP) or any avail- able writeable filesystem upon pressing F10. This is a modified version of CrScreenshotDxe driver by Nikolaj Schlej.\n• ExFatDxe — Proprietary ExFAT file system driver for Bootcamp support commonly found in Apple firmware. For Sandy Bridge and earlier CPUs, the ExFatDxeLegacy driver should be used due to the lack of RDRAND instruction support.\n• HfsPlus — Recommended. Proprietary HFS file system driver with bless support commonly found in Apple firmware. For Sandy Bridge and earlier CPUs, the HfsPlusLegacy driver should be used due to the lack of RDRAND instruction support.\n• HiiDatabase* — HII services support driver from MdeModulePkg. This driver is included in most types of firmware starting with the Ivy Bridge generation. Some applications with GUI, such as UEFI Shell, may need this driver to work properly.\n• EnhancedFatDxe — FAT filesystem driver from FatPkg. This driver is embedded in all UEFI firmware and cannot be used from OpenCore. Several types of firmware have defective FAT support implementation that may lead to corrupted filesystems on write attempts. Embedding this driver within the firmware may be required in case writing to the EFI partition is needed during the boot process.\n• NvmExpressDxe — NVMe support driver from MdeModulePkg. This driver is included in most firmware starting with the Broadwell generation. For Haswell and earlier, embedding it within the firmware may be more favourable in case a NVMe SSD drive is installed.\nOpenCanopy* — OpenCore plugin implementing graphical interface.\nOpenRuntime* — OpenCore plugin implementing OC_FIRMWARE_RUNTIME protocol.\n• OpenUsbKbDxe* — USB keyboard driver adding support for AppleKeyMapAggregator protocols on top of a custom USB keyboard driver implementation. This is an alternative to builtin KeySupport, which may work better or worse depending on the firmware.\n• OpenPartitionDxe* — Partition management driver with Apple Partitioning Scheme support. This driver can be used to support loading older DMG recoveries such as macOS 10.9 using Apple Partitioning Scheme. OpenDuet already includes this driver.\n• Ps2KeyboardDxe* — PS/2 keyboard driver from MdeModulePkg. OpenDuetPkg and some types of firmware may not include this driver, but it is necessary for PS/2 keyboard to work. Note, unlike OpenUsbKbDxe this driver has no AppleKeyMapAggregator support and thus requires KeySupport to be enabled.\n• Ps2MouseDxe* — PS/2 mouse driver from MdeModulePkg. Some very old laptop firmware may not include this driver but it is necessary for the touchpad to work in UEFI graphical interfaces such as OpenCanopy.\n• OpenHfsPlus* — HFS file system driver with bless support. This driver is an alternative to a closed source HfsPlus driver commonly found in Apple firmware. While it is feature complete, it is approximately 3 times slower and is yet to undergo a security audit.\n• UsbMouseDxe* — USB mouse driver from MdeModulePkg. Some virtual machine firmware such as OVMF may not include this driver but it is necessary for the mouse to work in UEFI graphical interfaces such as OpenCanopy.\n• XhciDxe* — XHCI USB controller support driver from MdeModulePkg. This driver is included in most types of firmware starting with the Sandy Bridge generation. For earlier firmware or legacy systems, it may be used to support external USB 3.0 PCI cards.\n\nDriver marked with * are bundled with OpenCore. To compile the drivers from UDK (EDK II) the same command used for OpenCore compilation can be taken, but choose a corresponding package:\ngit clone https://github.com/acidanthera/audk UDK cd UDK\nsource edksetup.sh\nmake -C BaseTools\nbuild -a X64 -b RELEASE -t XCODE5 -p FatPkg/FatPkg.dsc\nbuild -a X64 -b RELEASE -t XCODE5 -p MdeModulePkg/MdeModulePkg.dsc"; ObjectID = "6zo-Jl-Ryl"; */
"6zo-Jl-Ryl.ibShadowedToolTip" = "Chargez les pilotes sélectionnés à partir du répertoire OC / Drivers. \n Notez l'ordre de remplissage \n Selon le matériel, différents pilotes peuvent être nécessaires. Le chargement de pilotes incompatibles peut entraîner un démarrage impossible du système ou même endommager définitivement le micrologiciel. Certains pilotes connus incluent: \n  • Pilote de démarrage du système de fichiers ApfsDriverLoader-APFS. Ajout de la prise en charge des pilotes APFS intégrés dans le conteneur APFS amorçable du micrologiciel UEFI. \n  • FwRuntimeServices - Améliore la sécurité d'OpenCore et de Lilu en prenant en charge les variables NVRAM en lecture seule et en lecture seule. Certaines bizarreries (telles que RequestBootVarRouting) nécessitent ce pilote pour fonctionner correctement. En raison de la nature du pilote d'exécution en temps réel, qui s'exécute en parallèle avec le système d'exploitation cible, il ne peut pas être implémenté dans OpenCore lui-même, mais est fourni avec la distribution OpenCore. \n  • Pilote du système de fichiers EnhancedFatDxe-FatPkg FAT. Ce pilote est intégré à tous les micrologiciels UEFI et ne peut pas être utilisé à partir d'OpenCore. Comme nous le savons tous, il existe des erreurs dans la mise en œuvre de la prise en charge FAT pour divers micrologiciels, ce qui peut endommager le système de fichiers lors de la tentative d'écriture. Si la partition EFI doit être écrite pendant le processus de démarrage, il se peut que ce pilote doive être intégré dans le micrologiciel. \n  • Pilote de support NvmExpressDxe-NVMe de MdeModulePkg. Ce pilote est inclus dans la plupart des micrologiciels de la génération Broadwell. Pour Haswell et les versions antérieures, si un disque SSD NVMe est installé, il est préférable de l'intégrer dans le micrologiciel. \n  • Le pilote de clavier USB UsbKbDxe ajoute la prise en charge du protocole AppleKeyMapAggregator basé sur l'implémentation du pilote de clavier USB personnalisé. Il s'agit d'une alternative au KeySupport intégré. \n  • VBoxHfs-possède un pilote qui prend en charge le système de fichiers HFS. Ce pilote peut remplacer le pilote HFSPlus à source fermée communément trouvé dans le micrologiciel Apple. Bien que pleinement fonctionnel, il est environ trois fois plus lent et n'a pas encore fait l'objet d'audits de sécurité. \n  • Le contrôleur USB XHCI dans XhciDxe-MdeModulePkg prend en charge les pilotes. Ce pilote est inclus dans la plupart des micrologiciels de la génération Sandy Bridge. Pour les anciens micrologiciels ou les anciens systèmes, il peut être utilisé pour prendre en charge les cartes PCI USB 3.0 externes \n  • Module d'interface graphique tiers OC standard NdkBootPicker";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Play chime sound at startup.\n\nEnabling this setting plays the boot chime using the builtin audio support. The volume level is determined by the MinimumVolume and VolumeAmplifier settings as well as the SystemAudioVolume NVRAM variable. Possible values include:\n• Auto — Enables chime when StartupMute NVRAM variable is not present or set to 00.\n• Enabled — Enables chime unconditionally.\n• Disabled — Disables chime unconditionally.\n\nNote: Enabled can be used in separate from StartupMute NVRAM variable to avoid conflicts when the firmware is able to play the boot chime."; ObjectID = "77y-Lm-hgl"; */
"77y-Lm-hgl.ibShadowedToolTip" = "Type: plist string\nFailsafe: Auto\nDescription: Play chime sound at startup.\n\nEnabling this setting plays the boot chime using the builtin audio support. The volume level is determined by the MinimumVolume and VolumeAmplifier settings as well as the SystemAudioVolume NVRAM variable. Possible values include:\n• Auto — Enables chime when StartupMute NVRAM variable is not present or set to 00.\n• Enabled — Enables chime unconditionally.\n• Disabled — Disables chime unconditionally.\n\nNote: Enabled can be used in separate from StartupMute NVRAM variable to avoid conflicts when the firmware is able to play the boot chime.";

/* Class = "NSTextFieldCell"; title = "MinVersion"; ObjectID = "7Ns-yB-e5j"; */
"7Ns-yB-e5j.title" = "MinVersion";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load embedded APFS drivers from APFS containers.\n\nAn APFS EFI driver is bundled in all bootable APFS containers. This option performs the loading of signed APFS drivers (consistent with the ScanPolicy). Refer to the “EFI Jumpstart” section of the Apple File System Reference for details."; ObjectID = "8Sc-F2-ONI"; */
"8Sc-F2-ONI.ibShadowedToolTip" = "Type: plist boolean \n Failsafe: false \n Description: charge les pilotes APFS intégrés à partir des conteneurs APFS. \n Le pilote EFS APFS est fourni dans tous les conteneurs APFS amorçables. Cette option effectue le chargement des pilotes APFS signés par rapport à ScanPolicy. Voir plus de détails dans la section «EFI Jumpstart» de la référence du système de fichiers Apple. ";

/* Class = "NSTabViewItem"; label = "ReservedMemory"; ObjectID = "8vC-O7-rpe"; */
"8vC-O7-rpe.label" = "ReservedMemory";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Provide GOP protocol instances on top of UGA protocol instances.\n\nThis option provides the GOP protocol via a UGA-based proxy for firmware that do not implement the protocol.\n\nNote: This option requires ProvideConsoleGop to be enabled."; ObjectID = "90N-0m-rfm"; */
"90N-0m-rfm.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Provide GOP protocol instances on top of UGA protocol instances.\n\nThis option provides the GOP protocol via a UGA-based proxy for firmware that do not implement the protocol.\n\nNote: This option requires ProvideConsoleGop to be enabled.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Perform UEFI controller connection after driver loading.\nThis option is useful for loading drivers following UEFI driver model, as they may not start by themselves. Examples of such drivers are filesystem or audio drivers. While effective, this option may not be necessary for drivers performing automatic connection, and may slightly slowdown the boot.\n\nNote: Some types of firmware, particularly those made by Apple, only connect the boot drive to speed up the boot process. Enable this option to be able to see all the boot options when running multiple drives."; ObjectID = "9f0-xd-rhT"; */
"9f0-xd-rhT.ibShadowedToolTip" = "Une fois le pilote chargé, effectuez la connexion du contrôleur UEFI. Cette option est utile pour charger des pilotes de système de fichiers, qui suivent généralement le modèle de pilote UEFI et peuvent ne pas démarrer d'eux-mêmes. Bien qu'efficace, cette option peut ne pas être nécessaire pour les pilotes qui effectuent des connexions automatiques et peut ralentir légèrement le démarrage.";

/* Class = "NSTextFieldCell"; title = "MinDate"; ObjectID = "9fO-yG-VWd"; */
"9fO-yG-VWd.title" = "MinDate";

/* Class = "NSButtonCell"; title = "FirmwareVolume"; ObjectID = "AW6-UR-4Ex"; */
"AW6-UR-4Ex.title" = "FirmwareVolume";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Codec address on the specified audio controller for audio support. This typically contains the first audio codec address on the builtin analog audio controller (HDEF). Audio codec addresses, e.g. 2, can be found in the debug log: \nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs) \nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative this value can be obtained from IOHDACodecDevice class in I/O Registry containing it in IOHDACodecAddress field."; ObjectID = "AZW-9D-hq6"; */
"AZW-9D-hq6.ibShadowedToolTip" = "Adresse du codec sur le contrôleur audio spécifié pour la prise en charge audio. Habituellement, il contient l'adresse du premier codec audio sur le contrôleur audio analogique intégré (HDEF). L'adresse du codec audio, telle que 2, se trouve dans le journal de débogage: \n OCAU: 1/3 PciRoot (0x0) / Pci (0x1,0x0) / Pci (0x0,0x1) / VenMsg (<réduit>, 00000000) ( 4 sorties) \n OCAU: 2/3 PciRoot (0x0) / Pci (0x3,0x0) / VenMsg (<redaged>, 00000000) (1 sorties) \n OCAU: 3/3 PciRoot (0x0) / Pci (0x1B, 0x0) / VenMsg (<redaged>, 02000000) (7 sorties) \n  \n  Alternativement, cette valeur peut être obtenue à partir de la classe IOHDACodecDevice dans le logiciel de registre d'E / S, qui est contenue dans le champ IOHDACodecAddress.";

/* Class = "NSTextFieldCell"; title = "KeyInitialDelay"; ObjectID = "Bng-Xc-8Qm"; */
"Bng-Xc-8Qm.title" = "KeyInitialDelay";

/* Class = "NSButtonCell"; title = "AppleUserInterfaceTheme"; ObjectID = "BvY-5w-QBw"; */
"BvY-5w-QBw.title" = "AppleUserInterfaceTheme";

/* Class = "NSButtonCell"; title = "Scan/Browse"; ObjectID = "CLg-lY-N26"; */
"CLg-lY-N26.title" = "Parcourir";

/* Class = "NSButtonCell"; title = "IgnoreInvalidFlexRatio"; ObjectID = "CWI-LU-4dW"; */
"CWI-LU-4dW.title" = "IgnoreInvalidFlexRatio";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Activates HPET support.\n\nOlder boards like ICH6 may not always have HPET setting in the firmware preferences, this option tries to force enable it."; ObjectID = "CnN-YN-AWu"; */
"CnN-YN-AWu.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Activates HPET support.\n\nOlder boards like ICH6 may not always have HPET setting in the firmware preferences, this option tries to force enable it.";

/* Class = "NSButtonCell"; title = "ForgeUefiSupport"; ObjectID = "D5d-rU-CDJ"; */
"D5d-rU-CDJ.title" = "ForgeUefiSupport";

/* Class = "NSButtonCell"; title = "AppleSmcIo"; ObjectID = "Ddl-D0-484"; */
"Ddl-D0-484.title" = "AppleSmcIo";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Swap Command and Option keys during submission.\nThis option may be useful for keyboard layouts with Option key situated to the right of Command key."; ObjectID = "EIc-ff-Thn"; */
"EIc-ff-Thn.ibShadowedToolTip" = "Commutez les touches Commande et Option, sélectionnez généralement NON";

/* Class = "NSTextFieldCell"; title = "KeySupportMode"; ObjectID = "EeU-wj-caf"; */
"EeU-wj-caf.title" = "KeySupportMode";

/* Class = "NSButtonCell"; title = "PointerSupport"; ObjectID = "Elq-pL-QTD"; */
"Elq-pL-QTD.title" = "PointerSupport";

/* Class = "NSTextFieldCell"; title = "VolumeAmplifier"; ObjectID = "En7-ww-Uj5"; */
"En7-ww-Uj5.title" = "VolumeAmplifier";

/* Class = "NSTextFieldCell"; title = "KeyForgetThreshold"; ObjectID = "ErN-ks-EzO"; */
"ErN-ks-EzO.title" = "KeyForgetThreshold";

/* Class = "NSTabViewItem"; label = "APFS"; ObjectID = "F1Q-I5-6w7"; */
"F1Q-I5-6w7.label" = "APFS";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple SMC I/O protocol with a builtin version.\n\nThis protocol replaces the legacy VirtualSmc UEFI driver, and is compatible with any SMC kernel extension. \nHowever, in case FakeSMC kernel extension is used, manual NVRAM key variable addition may be needed."; ObjectID = "FPA-9t-OzA"; */
"FPA-9t-OzA.ibShadowedToolTip" = "La dernière version intègre le protocole VirtualSmc.efi. \n Utilisez cette option pour supprimer le fichier VirtualSmc.efi dans le répertoire des pilotes. \n Cependant, si vous utilisez l'extension du noyau FakeSMC, vous devrez peut-être ajouter manuellement la variable de clé NVRAM.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Perform full device connection during APFS loading.\n\nEvery handle is connected recursively instead of the partition handle connection typically used for APFS driver loading. This may result in additional time being taken but can sometimes be the only way to access APFS partitions on certain firmware, such as those on older HP laptops."; ObjectID = "H5Y-DY-WOe"; */
"H5Y-DY-WOe.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Perform full device connection during APFS loading.\n\nEvery handle is connected recursively instead of the partition handle connection typically used for APFS driver loading. This may result in additional time being taken but can sometimes be the only way to access APFS partitions on certain firmware, such as those on older HP laptops.";

/* Class = "NSButtonCell"; title = "ReplaceTabWithSpace"; ObjectID = "HIh-Oc-UT7"; */
"HIh-Oc-UT7.title" = "ReplaceTabWithSpace";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Hide verbose output from APFS driver.\nAPFS verbose output can be useful for debugging."; ObjectID = "HdB-KO-x50"; */
"HdB-KO-x50.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Hide verbose output from APFS driver.\nAPFS verbose output can be useful for debugging.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces Hash Services protocols with builtin versions. Set to true to ensure FileVault 2 compatibility on platforms with defective SHA-1 hash implementations. This can be determined by an invalid cursor size when UIScale is set to 02. Platforms earlier than APTIO V (Haswell and older) are typically affected."; ObjectID = "HpH-bP-96S"; */
"HpH-bP-96S.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Réparer le problème de taille de curseur de souris incorrecte lors de l'exécution de FileVault, défini sur OUI pour une meilleure compatibilité avec FileVault";

/* Class = "NSButtonCell"; title = "DisableSecurityPolicy"; ObjectID = "IID-nc-awv"; */
"IID-nc-awv.title" = "DisableSecurityPolicy";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Image Conversion protocol with a builtin version."; ObjectID = "ILy-av-YYi"; */
"ILy-av-YYi.ibShadowedToolTip" = "Reconstruisez l'icône de la pomme, sélectionnez généralement NON.";

/* Class = "NSTabViewItem"; label = "ProtocolOverrides"; ObjectID = "Ife-ug-MJ5"; */
"Ife-ug-MJ5.label" = "Substitutions de protocole";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Debug Log protocol with a builtin version."; ObjectID = "JLv-Tn-pJQ"; */
"JLv-Tn-pJQ.ibShadowedToolTip" = "Réinstallez le protocole Apple Debug Log avec une version intégrée.";

/* Class = "NSTextFieldCell"; title = "KeySubsequentDelay"; ObjectID = "JWy-Kv-Tq6"; */
"JWy-Kv-Tq6.title" = "KeySubsequentDelay";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Data Hub protocol with a builtin version.\n\nNote: This will discard all previous entries if the protocol was already installed, so all properties required for the safe operation of the system must be specified in the configuration file."; ObjectID = "KN0-dq-pSV"; */
"KN0-dq-pSV.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Data Hub protocol with a builtin version.\n\nNote: This will discard all previous entries if the protocol was already installed, so all properties required for the safe operation of the system must be specified in the configuration file.";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Enable custom key repeat delays when using the OpenCore implementation of the Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\n• Auto — Treated as Enabled when KeySupport is true and Disabled otherwise.\n• Enabled — The values KeyInitialDelay and KeySubsequentDelay are used.\n• Disabled — Apple default values of 500ms (50) and 50ms (5) are used."; ObjectID = "Kmw-jC-ANj"; */
"Kmw-jC-ANj.ibShadowedToolTip" = "Type: plist string\nFailsafe: Auto\nDescription: Enable custom key repeat delays when using the OpenCore implementation of the Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\n• Auto — Treated as Enabled when KeySupport is true and Disabled otherwise.\n• Enabled — The values KeyInitialDelay and KeySubsequentDelay are used.\n• Disabled — Apple default values of 500ms (50) and 50ms (5) are used.";

/* Class = "NSTextFieldCell"; title = "AudioCodec"; ObjectID = "L2f-gE-rBP"; */
"L2f-gE-rBP.title" = "AudioCodec";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver date.\n\nThe APFS driver date connects the APFS driver with the calendar release date. Apple ultimately drops support for older macOS releases and APFS drivers from such releases may contain vulnerabilities that can be used to compromise a computer if such drivers are used after support ends. This option permits restricting APFS drivers to current macOS versions.\n\n• 0 — require the default supported release date of APFS in OpenCore. The default release date will increase with time and thus this setting is recommended. Currently set to 2020/01/01.\n• -1 — permit any release date to load (strongly discouraged).\n• Other — use custom minimal APFS release date, e.g. 20200401 for 2020/04/01. APFS release dates can be found in OpenCore boot log and OcApfsLib."; ObjectID = "L9i-6i-Mis"; */
"L9i-6i-Mis.ibShadowedToolTip" = "Type: entier plist \n Failsafe: 0 \n Description: Date de pilote APFS minimale autorisée. \n La date de pilote APFS connecte le pilote APFS à la date de sortie du calendrier. Les versions plus anciennes des pilotes APFS peuvent contenir des vulnérabilités non corrigées, qui peuvent être utilisées pour endommager votre ordinateur. Cette option permet de restreindre les pilotes APFS aux seules versions récentes. \n  • 0 - nécessite la date de sortie prise en charge par défaut d'APFS dans OpenCore. La date de sortie par défaut augmentera avec le temps et ce paramètre est donc recommandé. Actuellement défini sur 2020/01/01. \n  • -1 - autorise le chargement de toute date de sortie (fortement déconseillé). \n  • Autre - utilisez une date de sortie APFS minimale personnalisée, par exemple 20200401 pour 2020/04/01. Les dates de sortie d'APFS peuvent être trouvées dans le journal de démarrage d'OpenCore et OcApfsLib.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 50 (500ms before first key repeat)\nDescription: Configures the initial delay before keyboard key repeats in OpenCore implementation of Apple Event protocol, in units of 10ms.\n\nThe Apple OEM default value is 50 (500ms).\n\nNote 1: On systems not using \\texttt{KeySupport}, this setting may be freely used to configure key repeat behaviour.\n\nNote 2: On systems using \\texttt{KeySupport}, but which do not show the 'two long delays' behavior (see Note 3) and/or which always show a solid 'set default' indicator (see KeyForgetThreshold) then this setting may also be freely used to configure key repeat initial delay behaviour, except that it should never be set to less than KeyForgetThreshold to avoid uncontrolled key repeats.\n\nNote 3: On some systems using KeySupport, you may find that you see one additional slow key repeat before normal speed key repeat starts, when holding a key down. If so, you may wish to configure KeyInitialDelay and KeySubsequentDelay according to the instructions at Note 3 of KeySubsequentDelay."; ObjectID = "LPe-Zp-8MC"; */
"LPe-Zp-8MC.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 50 (500ms before first key repeat)\nDescription: Configures the initial delay before keyboard key repeats in OpenCore implementation of Apple Event protocol, in units of 10ms.\n\nThe Apple OEM default value is 50 (500ms).\n\nNote 1: On systems not using \\texttt{KeySupport}, this setting may be freely used to configure key repeat behaviour.\n\nNote 2: On systems using \\texttt{KeySupport}, but which do not show the 'two long delays' behavior (see Note 3) and/or which always show a solid 'set default' indicator (see KeyForgetThreshold) then this setting may also be freely used to configure key repeat initial delay behaviour, except that it should never be set to less than KeyForgetThreshold to avoid uncontrolled key repeats.\n\nNote 3: On some systems using KeySupport, you may find that you see one additional slow key repeat before normal speed key repeat starts, when holding a key down. If so, you may wish to configure KeyInitialDelay and KeySubsequentDelay according to the instructions at Note 3 of KeySubsequentDelay.";

/* Class = "NSButtonCell"; title = "OSInfo"; ObjectID = "Ljq-q2-IwF"; */
"Ljq-q2-IwF.title" = "OSInfo";

/* Class = "NSTableColumn"; headerCell.title = "Type"; ObjectID = "McE-CL-fQD"; */
"McE-CL-fQD.headerCell.title" = "Type";

/* Class = "NSTextFieldCell"; title = "SetupDelay"; ObjectID = "N4u-Hw-eXM"; */
"N4u-Hw-eXM.title" = "SetupDelay";

/* Class = "NSButtonCell"; title = "DataHub"; ObjectID = "NGa-cY-Uzn"; */
"NGa-cY-Uzn.title" = "DataHub";

/* Class = "NSTextFieldCell"; title = "Resolution"; ObjectID = "NbU-Qi-Xhw"; */
"NbU-Qi-Xhw.title" = "Résolution de la console";

/* Class = "NSButtonCell"; title = "KeyFiltering"; ObjectID = "Of8-Ba-FhQ"; */
"Of8-Ba-FhQ.title" = "KeyFiltering";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 5 (50ms between subsequent key repeats)\nDescription: Configures the gap between keyboard key repeats in OpenCore implementation of Apple Event protocol, in units of 10ms.\n\nThe Apple OEM default value is 5 (50ms).\n0 is an invalid value for this option (will issue a debug log warning and use 1 instead).\n\nNote 1: On systems not using KeySupport, this setting may be freely used to configure key repeat behaviour.\n\nNote 2: On systems using KeySupport, but which do not show the 'two long delays' behaviour (see Note 3) and/or which always show a solid 'set default' indicator (see KeyForgetThreshold) (which should apply to many/most systems using AMI KeySupport mode) then this setting may be freely used to configure key repeat subsequent delay behaviour, except that it should never be set to less than KeyForgetThreshold to avoid uncontrolled key repeats.\n\nNote 3: On some systems using KeySupport, particularly KeySupport in non-AMI mode, you may find that after configuring KeyForgetThreshold you get one additional slow key repeat before normal speed key repeat starts, when holding a key down. On systems where this is the case, it is an unavoidable artefect of using KeySupport to emulate raw keyboard data, which is not made available by UEFI. While this 'two long delays' issue has minimal effect on overall usability, nevertheless you may wish to resolve it, and it is possible to do so as follows:\n• Set CustomDelays to true\n• Set KeyInitialDelay to 0\n• Set KeySubsequentDelay to at least the value of your KeyForgetThreshold setting\n\nThe above procedure works as follows:\n• Setting KeyInitialDelay to 0 cancels the Apple Event initial repeat delay (when using the OC builtin Apple Event implementation with CustomDelays enabled), therefore the only long delay you will see is the the non-configurable and non-avoidable initial long delay introduced by the BIOS key support on these machines.\n• Key-smoothing parameter KeyForgetThreshold effectively acts as the shortest time for which a key can appear to be held, therefore a key repeat delay of less than this will guarantee at least one extra repeat for every key press, however quickly the key is physically tapped.\n• In the unlikely event that you still get frequent, or occasional, double key responses after setting KeySubsequentDelay equal to your system's value of KeyForgetThreshold, then increase KeySubsequentDelay by one or two more until this effect goes away."; ObjectID = "Op9-Rz-IAN"; */
"Op9-Rz-IAN.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 5 (50ms between subsequent key repeats)\nDescription: Configures the gap between keyboard key repeats in OpenCore implementation of Apple Event protocol, in units of 10ms.\n\nThe Apple OEM default value is 5 (50ms).\n0 is an invalid value for this option (will issue a debug log warning and use 1 instead).\n\nNote 1: On systems not using KeySupport, this setting may be freely used to configure key repeat behaviour.\n\nNote 2: On systems using KeySupport, but which do not show the 'two long delays' behaviour (see Note 3) and/or which always show a solid 'set default' indicator (see KeyForgetThreshold) (which should apply to many/most systems using AMI KeySupport mode) then this setting may be freely used to configure key repeat subsequent delay behaviour, except that it should never be set to less than KeyForgetThreshold to avoid uncontrolled key repeats.\n\nNote 3: On some systems using KeySupport, particularly KeySupport in non-AMI mode, you may find that after configuring KeyForgetThreshold you get one additional slow key repeat before normal speed key repeat starts, when holding a key down. On systems where this is the case, it is an unavoidable artefect of using KeySupport to emulate raw keyboard data, which is not made available by UEFI. While this 'two long delays' issue has minimal effect on overall usability, nevertheless you may wish to resolve it, and it is possible to do so as follows:\n• Set CustomDelays to true\n• Set KeyInitialDelay to 0\n• Set KeySubsequentDelay to at least the value of your KeyForgetThreshold setting\n\nThe above procedure works as follows:\n• Setting KeyInitialDelay to 0 cancels the Apple Event initial repeat delay (when using the OC builtin Apple Event implementation with CustomDelays enabled), therefore the only long delay you will see is the the non-configurable and non-avoidable initial long delay introduced by the BIOS key support on these machines.\n• Key-smoothing parameter KeyForgetThreshold effectively acts as the shortest time for which a key can appear to be held, therefore a key repeat delay of less than this will guarantee at least one extra repeat for every key press, however quickly the key is physically tapped.\n• In the unlikely event that you still get frequent, or occasional, double key responses after setting KeySubsequentDelay equal to your system's value of KeyForgetThreshold, then increase KeySubsequentDelay by one or two more until this effect goes away.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal heard volume level from 0 to 100.\n\nThe screen reader will use this volume level when the calculated volume level is lower than MinimumVolume and the boot chime will not play if the calculated volume level is lower than MinimumVolume."; ObjectID = "PF5-bc-9Z2"; */
"PF5-bc-9Z2.ibShadowedToolTip" = "Le volume minimum est compris entre 0 et 100. \n  \n Lorsque le niveau de volume calculé est inférieur à MinimumVolume, le lecteur d'écran utilisera ce niveau de volume. Si le volume calculé est inférieur à MinimumVolume, aucune tonalité de démarrage ne retentira.";

/* Class = "NSButtonCell"; title = "AppleAudio"; ObjectID = "POq-ge-Ugg"; */
"POq-ge-Ugg.title" = "AppleAudio";

/* Class = "NSBox"; title = "Quirks"; ObjectID = "PVa-Cc-beC"; */
"PVa-Cc-beC.title" = "Quirks";

/* Class = "NSTextFieldCell"; title = "PlayChime"; ObjectID = "PpL-lt-ruw"; */
"PpL-lt-ruw.title" = "PlayChime";

/* Class = "NSTextFieldCell"; title = "TextRenderer"; ObjectID = "QQF-qM-yZS"; */
"QQF-qM-yZS.title" = "TextRenderer(Rendu de texte)";

/* Class = "NSTextFieldCell"; title = "AppleEvent"; ObjectID = "SCl-CT-PaY"; */
"SCl-CT-PaY.title" = "AppleEvent";

/* Class = "NSButtonCell"; title = "GlobalConnect"; ObjectID = "SDU-Ok-pEv"; */
"SDU-Ok-pEv.title" = "GlobalConnect";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 1\nDescription: Configure pointer speed multiplier in OpenCore implementation of Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\nConfigures the multiplier for pointer movements. The Apple OEM default value is 1.\n\nNote: The recommended value for this option is 1. This value may optionally be modified in combination with PointerSpeedDiv, according to user preference, to achieve customised mouse movement scaling."; ObjectID = "TSX-3o-2jP"; */
"TSX-3o-2jP.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 1\nDescription: Configure pointer speed multiplier in OpenCore implementation of Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\nConfigures the multiplier for pointer movements. The Apple OEM default value is 1.\n\nNote: The recommended value for this option is 1. This value may optionally be modified in combination with PointerSpeedDiv, according to user preference, to achieve customised mouse movement scaling.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Attempt to detach USB controller ownership from the firmware driver. While most types of firmware manage to do this properly, or at least have an option for this, some do not. As a result, the operating system may freeze upon boot. Not recommended unless specifically required."; ObjectID = "TTJ-UT-Xng"; */
"TTJ-UT-Xng.ibShadowedToolTip" = "La plupart des cartes mères ont pour fonction de libérer automatiquement la propriété USB. Nous choisissons NON. Si votre clavier et votre souris sont bloqués ou que la clé USB échoue, essayez de choisir Oui.";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Set internal keyboard input translation to AppleKeyMapAggregator protocol mode.\n• Auto — Performs automatic choice as available with the following preference: AMI, V2, V1.\n• V1 — Uses UEFI standard legacy input protocol EFI_SIMPLE_TEXT_INPUT_PROTOCOL.\n• V2 — Uses UEFI standard modern input protocol EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.\n• AMI — Uses APTIO input protocol AMI_EFIKEYCODE_PROTOCOL.\n\nNote: Currently V1, V2, and AMI unlike Auto only do filtering of the particular specified protocol. This may change in the future versions."; ObjectID = "TTL-Rn-Avg"; */
"TTL-Rn-Avg.ibShadowedToolTip" = "Auto: mode de protocole de conversion de valeurs-clés \n V1: protocole d'entrée hérité UEFI \n V2: nouveau protocole d'entrée UEFI \n AMI: protocole d'entrée APTIO";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver version.\n\nThe APFS driver version connects the APFS driver with the macOS release. Apple ultimately drops support for older macOS releases and APFS drivers from such releases may contain vulnerabilities that can be used to compromise a computer if such drivers are used after support ends. This option permits restricting APFS drivers to current macOS versions.\n\n• 0 — require the default supported version of APFS in OpenCore. The default version will increase with time and thus this setting is recommended. Currently set to the latest point release from High Sierra.\n• -1 — permit any version to load (strongly discouraged).\n• Other — use custom minimal APFS version, e.g. 1412101001000000 from macOS Catalina 10.15.4. APFS versions can be found in OpenCore boot log and OcApfsLib."; ObjectID = "TYZ-jG-lfr"; */
"TYZ-jG-lfr.ibShadowedToolTip" = "Type: entier plist \n Failsafe: 0 \n Description: Version minimale autorisée du pilote APFS. \n La version du pilote APFS connecte le pilote APFS à la version macOS. Les pilotes APFS des anciennes versions de macOS ne seront plus pris en charge et peuvent donc contenir des vulnérabilités non corrigées, qui peuvent être utilisées pour endommager votre ordinateur. Cette option permet de limiter les pilotes APFS aux seules versions modernes de macOS. \n  • 0 - nécessite la version prise en charge par défaut d'APFS dans OpenCore. La version par défaut augmentera avec le temps et ce paramètre est donc recommandé. Actuellement défini sur la dernière version ponctuelle de High Sierra. \n  • -1 - autorise le chargement de toute version (fortement déconseillé). \n  • Autre - utilisez une version APFS minimale personnalisée, par exemple 1412101001000000 de macOS Catalina 10.15.4. Les versions APFS peuvent être trouvées dans le journal de démarrage OpenCore et OcApfsLib.";

/* Class = "NSButtonCell"; title = "ReleaseUsbOwnership"; ObjectID = "UMT-DK-9B5"; */
"UMT-DK-9B5.title" = "ReleaseUsbOwnership";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Device Property protocol with a builtin version. This may be used to ensure full compatibility on VMs and legacy Macs.\n\nNote: This will discard all previous entries if the protocol was already installed, so all properties required for safe operation of the system must be specified in the configuration file."; ObjectID = "Ueb-hn-jBT"; */
"Ueb-hn-jBT.ibShadowedToolTip" = "Sélectionnez généralement NO \n  pour garantir une compatibilité totale sur la machine virtuelle ou la vieille pomme blanche.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Index of the output port of the specified codec starting from 0.\n\nThis typically contains the index of the green out of the builtin analog audio controller (HDEF). The number of output nodes (N) in the debug log (marked in bold):\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs) \n\nThe quickest way to find the right port is to bruteforce the values from 0 to N - 1."; ObjectID = "UrW-oc-0Oc"; */
"UrW-oc-0Oc.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 0\nDescription: Index of the output port of the specified codec starting from 0.\n\nThis typically contains the index of the green out of the builtin analog audio controller (HDEF). The number of output nodes (N) in the debug log (marked in bold):\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs) \n\nThe quickest way to find the right port is to bruteforce the values from 0 to N - 1.";

/* Class = "NSTabViewItem"; label = "Drivers"; ObjectID = "V9Z-z9-Ejd"; */
"V9Z-z9-Ejd.label" = "Pilote UEFI";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple IMG4 Verification protocol with a builtin version. This protocol is used to verify im4m manifest files used by Apple Secure Boot."; ObjectID = "XQL-ML-llQ"; */
"XQL-ML-llQ.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple IMG4 Verification protocol with a builtin version. This protocol is used to verify im4m manifest files used by Apple Secure Boot.";

/* Class = "NSButtonCell"; title = "AppleRtcRam"; ObjectID = "Xjp-N3-zFD"; */
"Xjp-N3-zFD.title" = "AppleRtcRam";

/* Class = "NSTabViewItem"; label = "AppleInput"; ObjectID = "XuU-Ep-ZXb"; */
"XuU-Ep-ZXb.label" = "AppleInput";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Disable platform security policy.\n\nNote: This setting disables various security features of the firmware, defeating the purpose of any kind of Secure Boot. Do NOT enable if using UEFI Secure Boot."; ObjectID = "Y1W-Rp-1xj"; */
"Y1W-Rp-1xj.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Disable platform security policy.\n\nNote: This setting disables various security features of the firmware, defeating the purpose of any kind of Secure Boot. Do NOT enable if using UEFI Secure Boot.";

/* Class = "NSButtonCell"; title = "UnblockFsConnect"; ObjectID = "YFj-X6-x1j"; */
"YFj-X6-x1j.title" = "UnblockFsConnect";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty\nDescription: Device path of the specified audio controller for audio support.\n\nThis typically contains builtin analog audio controller (HDEF) device path, e.g. PciRoot(0x0)/Pci(0x1b,0x0).\nThe list of recognised audio controllers can be found in the debug log:\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative gfxutil -f HDEF command can be used in macOS. Specifying an empty device path will result in the first available audio controller being used."; ObjectID = "YTE-Ba-80O"; */
"YTE-Ba-80O.ibShadowedToolTip" = "Chemin du périphérique pour le contrôleur audio spécifié pour la prise en charge des fonctionnalités audio. \n Habituellement, il contient le chemin de périphérique du contrôleur audio analogique (HDEF) intégré, tel que: PciRoot (0x0) / Pci (0x1b, 0x0). \n Une liste de contrôleurs audio se trouve dans le journal de débogage: \n OCAU: 1 / 3 PciRoot (0x0) / Pci (0x1,0x0) / Pci (0x0,0x1) / VenMsg (<expurgé>, 00000000) (4 sorties) \n OCAU: 2/3 PciRoot (0x0) / Pci (0x3,0x0) / VenMsg (<réduit>, 00000000) (1 sorties) \n OCAU: 3/3 PciRoot (0x0) / Pci (0x1B, 0x0) / VenMsg (<redigned>, 02000000) (7 sorties) \n  \n Également disponible sur Sous macOS, utilisez la commande gfxutil -f HDEF pour obtenir ou afficher l'adresse du périphérique audio à l'aide de l'outil Hackintool. Si vous spécifiez un chemin de périphérique vide, le premier contrôleur audio disponible sera utilisé.";

/* Class = "NSButtonCell"; title = "Download/Update drivers"; ObjectID = "YW9-8V-SGH"; */
"YW9-8V-SGH.title" = "Download/Update drivers";

/* Class = "NSButtonCell"; title = "UnicodeCollation"; ObjectID = "ZCa-Hx-UFl"; */
"ZCa-Hx-UFl.title" = "UnicodeCollation";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Use builtin graphics output protocol renderer for console.\n\nOn certain firmware, such as on the MacPro5,1, this may provide better performance or fix rendering issues. However, this option is not recommended unless there is an obvious benefit as it may result in issues such as slower scrolling."; ObjectID = "a3V-hG-HCC"; */
"a3V-hG-HCC.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Use builtin graphics output protocol renderer for console.\n\nOn certain firmware, such as on the MacPro5,1, this may provide better performance or fix rendering issues. However, this option is not recommended unless there is an obvious benefit as it may result in issues such as slower scrolling.";

/* Class = "NSTextFieldCell"; title = "PointerSupportMode"; ObjectID = "anR-lZ-CjV"; */
"anR-lZ-CjV.title" = "PointerSupportMode";

/* Class = "NSButtonCell"; title = "ProvideConsoleGop"; ObjectID = "bdr-Pu-Crr"; */
"bdr-Pu-Crr.title" = "ProvideConsoleGop";

/* Class = "NSButtonCell"; title = "ActivateHpetSupport"; ObjectID = "c2Y-XK-b7N"; */
"c2Y-XK-b7N.title" = "ActivateHpetSupport";

/* Class = "NSButtonCell"; title = "ResetTrafficClass"; ObjectID = "cgf-ad-vIe"; */
"cgf-ad-vIe.title" = "ResetTrafficClass";

/* Class = "NSButtonCell"; title = "KeySupport"; ObjectID = "cia-MM-Epa"; */
"cia-MM-Epa.title" = "KeySupport";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware do not print tab characters or everything that follows them, causing difficulties in using the UEFI Shell’s builtin text editor to edit property lists and other documents. This option makes the console output spaces instead of tabs.\n\nNote: This option only applies to System renderer."; ObjectID = "dDZ-Zb-RKY"; */
"dDZ-Zb-RKY.ibShadowedToolTip" = "Certains firmwares ne peuvent pas imprimer les onglets, ni même tout ce qui se trouve après les onglets, ce qui rend difficile, voire impossible, l'utilisation de l'éditeur de texte intégré au shell UEFI pour modifier les listes de propriétés et autres documents. Cette option entraîne le remplacement des onglets par l'espace de sortie de la console. \n Remarque: cette option fonctionne uniquement avec le rendu système.";

/* Class = "NSButtonCell"; title = "SanitiseClearScreen"; ObjectID = "dXN-AE-igp"; */
"dXN-AE-igp.title" = "SanitiseClearScreen";

/* Class = "NSButtonCell"; title = "AppleBootPolicy"; ObjectID = "ddJ-by-qVm"; */
"ddJ-by-qVm.title" = "AppleBootPolicy";

/* Class = "NSButtonCell"; title = "AppleKeyMap"; ObjectID = "dpz-CS-4eq"; */
"dpz-CS-4eq.title" = "AppleKeyMap";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal pointer driver.\n\nThis option implements standard UEFI pointer protocol (EFI_SIMPLE_POINTER_PROTOCOL) through select OEM protocols. The option may be useful on Z87 ASUS boards, where EFI_SIMPLE_POINTER_PROTOCOL is defective."; ObjectID = "dzp-p6-AHb"; */
"dzp-p6-AHb.ibShadowedToolTip" = "Si vous êtes un ASUS z87 ou z97, vous devez activer l'option PointerSupport.";

/* Class = "NSButtonCell"; title = "ReloadOptionRoms"; ObjectID = "eDn-1a-lDg"; */
"eDn-1a-lDg.title" = "ReloadOptionRoms";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Ensure GOP (Graphics Output Protocol) on console handle.\nmacOS bootloader requires GOP or UGA (for 10.4 EfiBoot) to be present on console handle, yet the exact location of  the graphics protocol is not covered by the UEFI specification. This option will ensure GOP and UGA, if present, are available on the console handle.\n\nNote: This option will also replace incompatible implementations of GOP on the console handle, as may be the case on the MacPro5,1 when using modern GPUs."; ObjectID = "eGd-xS-rQf"; */
"eGd-xS-rQf.ibShadowedToolTip" = "Avant de sélectionner l'écran système, vous pouvez voir des informations sur votre erreur de configuration de configuration. Vous pouvez ajuster votre configuration en fonction de ces informations, ou vous pouvez choisir OUI pour ignorer. Il est recommandé de choisir OUI.";

/* Class = "NSButtonCell"; title = "HideVerbose"; ObjectID = "egr-8J-RIS"; */
"egr-8J-RIS.title" = "HideVerbose";

/* Class = "NSTextFieldCell"; title = "MinimumVolume"; ObjectID = "ehu-K3-gbY"; */
"ehu-K3-gbY.title" = "MinimumVolume";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Provide UGA protocol instances on top of GOP protocol instances.\n\nSome types of firmware do not implement the legacy UGA protocol but this may be required for screen output by older EFI applications such as EfiBoot from 10.4."; ObjectID = "ejz-UL-xuF"; */
"ejz-UL-xuF.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Provide UGA protocol instances on top of GOP protocol instances.\n\nSome types of firmware do not implement the legacy UGA protocol but this may be required for screen output by older EFI applications such as EfiBoot from 10.4.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware reset screen resolutions to a failsafe value (such as 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround.\n\nNote: This option only applies to the System renderer. On all known affected systems, ConsoleMode must be set to an empty string for this option to work."; ObjectID = "f0k-6s-W9I"; */
"f0k-6s-W9I.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware reset screen resolutions to a failsafe value (such as 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround.\n\nNote: This option only applies to the System renderer. On all known affected systems, ConsoleMode must be set to an empty string for this option to work.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Query PCI devices and reload their Option ROMs if available.\n\nFor example, this option allows reloading NVIDIA GOP Option ROM on older Macs after the firmware version is upgraded via ForgeUefiSupport."; ObjectID = "fDO-pY-c74"; */
"fDO-pY-c74.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Query PCI devices and reload their Option ROMs if available.\n\nFor example, this option allows reloading NVIDIA GOP Option ROM on older Macs after the firmware version is upgraded via ForgeUefiSupport.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Set architecture timer resolution.\n\nThis option allows updating the firmware architecture timer period with the specified value in 100 nanosecond units. Setting a lower value typically improves performance and responsiveness of the interface and input handling.\n\nThe recommended value is 50000 (5 milliseconds) or slightly higher. Select ASUS Z87 boards use 60000 for the interface. Apple boards use 100000. In case of issues, this option can be left as 0."; ObjectID = "fda-QM-Vl4"; */
"fda-QM-Vl4.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 0\nDescription: Set architecture timer resolution.\n\nThis option allows updating the firmware architecture timer period with the specified value in 100 nanosecond units. Setting a lower value typically improves performance and responsiveness of the interface and input handling.\n\nThe recommended value is 50000 (5 milliseconds) or slightly higher. Select ASUS Z87 boards use 60000 for the interface. Apple boards use 100000. In case of issues, this option can be left as 0.";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Determine whether OC builtin or OEM Apple Event protocol is used.\n\nThis option determines whether Apple’s OEM Apple Event protocol is used (where available), or whether OpenCore’s reversed engineered and updated re-implementation is used. In general OpenCore’s re-implementation should be preferred, since it contains updates such as noticeably improved fine mouse cursor movement and configurable key repeat delays.\n\n• Auto — Use OEM Apple Event implementation if available, connected and recent enough to be used, otherwise use OC reimplementation. On non-Apple hardware this will use the OpenCore builtin implementation. On some Macs (e.g. classic Mac Pro) this will find the Apple implementation. On both older and newer Macs than this, this option will always or often use the OC implementation. On older Macs this is because the implementation available is too old to be used, on newer Macs it is because of optimisations added by Apple which do not connect the Apple Event protocol except when needed – e.g. except when the Apple boot picker is explicitly started. Due to its somewhat unpredicatable results, this option is not normally recommended.\n• Builtin — Always use OpenCore's updated re-implementation of the Apple Event protocol. Use of this setting is recommended even on Apple hardware, due to improvements (better fine mouse control, configurable key delays) made in the OC re-implementation of the protocol.\n• OEM — Assume Apple's protocol will be available at driver connection. On all Apple hardware where a recent enough Apple OEM version of the protocol is available -- whether or not connected automatically by Apple's firmware -- this option will reliably access the Apple implementation. On all other systems, this option will result in no keyboard or mouse support. For the reasons stated, \\texttt{Builtin} is recommended in preference to this option in most cases."; ObjectID = "frr-qu-WDh"; */
"frr-qu-WDh.ibShadowedToolTip" = "Type: plist string\nFailsafe: Auto\nDescription: Determine whether OC builtin or OEM Apple Event protocol is used.\n\nThis option determines whether Apple’s OEM Apple Event protocol is used (where available), or whether OpenCore’s reversed engineered and updated re-implementation is used. In general OpenCore’s re-implementation should be preferred, since it contains updates such as noticeably improved fine mouse cursor movement and configurable key repeat delays.\n\n• Auto — Use OEM Apple Event implementation if available, connected and recent enough to be used, otherwise use OC reimplementation. On non-Apple hardware this will use the OpenCore builtin implementation. On some Macs (e.g. classic Mac Pro) this will find the Apple implementation. On both older and newer Macs than this, this option will always or often use the OC implementation. On older Macs this is because the implementation available is too old to be used, on newer Macs it is because of optimisations added by Apple which do not connect the Apple Event protocol except when needed – e.g. except when the Apple boot picker is explicitly started. Due to its somewhat unpredicatable results, this option is not normally recommended.\n• Builtin — Always use OpenCore's updated re-implementation of the Apple Event protocol. Use of this setting is recommended even on Apple hardware, due to improvements (better fine mouse control, configurable key delays) made in the OC re-implementation of the protocol.\n• OEM — Assume Apple's protocol will be available at driver connection. On all Apple hardware where a recent enough Apple OEM version of the protocol is available -- whether or not connected automatically by Apple's firmware -- this option will reliably access the Apple implementation. On all other systems, this option will result in no keyboard or mouse support. For the reasons stated, \\texttt{Builtin} is recommended in preference to this option in most cases.";

/* Class = "NSButtonCell"; title = "GopPassThrough"; ObjectID = "g7Z-iK-sN1"; */
"g7Z-iK-sN1.title" = "GopPassThrough";

/* Class = "NSButtonCell"; title = "AppleSecureBoot"; ObjectID = "gC4-eW-BlL"; */
"gC4-eW-BlL.title" = "AppleSecureBoot";

/* Class = "NSTabViewItem"; label = "Output"; ObjectID = "gJG-UT-7D3"; */
"gJG-UT-7D3.label" = "Afficher la sortie liée";

/* Class = "NSButtonCell"; title = "KeySwap"; ObjectID = "h6b-rN-daY"; */
"h6b-rN-daY.title" = "KeySwap";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty (Maintain current screen resolution)\nDescription: Sets console output screen resolution.\n• Set to WxH@Bpp (e.g. 1920x1080@32) or WxH (e.g. 1920x1080) formatted string to request custom resolution from GOP if available.\n• Set to Max to attempt using the largest available screen resolution.\n\nOn HiDPI screens APPLE_VENDOR_VARIABLE_GUID UIScale NVRAM variable may need to be set to 02 to enable HiDPI scaling in FileVault 2 UEFI password interface and boot screen logo. Refer to Recommended Variables section for details.\n\nNote: This will fail when console handle has no GOP protocol. When the firmware does not provide it, it can be added with ProvideConsoleGop set to true."; ObjectID = "hVw-xH-z40"; Note = "Do Not Translate"; */
"hVw-xH-z40.ibShadowedToolTip" = "Définir la résolution d'écran de sortie de la console. \n  • Définir sur vide pour ne pas modifier la résolution d'écran. \n  • Définir sur Max pour essayer d'utiliser la plus grande résolution d'écran disponible. \n Remarque: si le descripteur de la console ne possède pas de protocole GOP, cela échouera. Vous pouvez définir la valeur True de ProviderConsoleGop pour l'ajouter.";

/* Class = "NSTableView"; ibShadowedToolTip = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Start address of the reserved memory region, which should be allocated as reserved effectively marking the memory of this type inaccessible to the operating system.\n\nThe addresses written here must be part of the memory map, have a EfiConventionalMemory type, and page-aligned (4 KBs).\n\nNote: Some types of firmware may not allocate memory areas used by S3 (sleep) and S4 (hibernation) code unless CSM is enabled causing wake failures. After comparing the memory maps with CSM disabled and enabled you could find these areas in the lower memory and fix them up by doing the reservation. Reger to the Sample.plist for details.\n\n2. Comment\nType: plist string\nFailsafe: Empty\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. Whether this value is used is implementation defined.\n3. Size\nType: plist integer\nFailsafe: 0\nDescription: Size of the reserved memory region, must be page-aligned (4 KBs).\n4. Type\nType: plist string\nFailsafe: Reserved\nDescription: Memory region type matching the UEFI specification memory descriptor types. Mapping:\n• Reserved — EfiReservedMemoryType\n• LoaderCode — EfiLoaderCode\n• LoaderData — EfiLoaderData\n• BootServiceCode — EfiBootServicesCode\n• BootServiceData — EfiBootServicesData\n• RuntimeCode — EfiRuntimeServicesCode\n• RuntimeData — EfiRuntimeServicesData\n• Available — EfiConventionalMemory\n• Persistent — EfiPersistentMemory\n• UnusableMemory — EfiUnusableMemory\n• ACPIReclaimMemory — EfiACPIReclaimMemory\n• ACPIMemoryNVS — EfiACPIMemoryNVS\n• MemoryMappedIO — EfiMemoryMappedIO\n• MemoryMappedIOPortSpace — EfiMemoryMappedIOPortSpace\n• PalCode — EfiPalCode\n5. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This region will not be reserved unless set to true."; ObjectID = "hs4-gm-1Ct"; */
"hs4-gm-1Ct.ibShadowedToolTip" = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Start address of the reserved memory region, which should be allocated as reserved effectively marking the memory of this type inaccessible to the operating system.\n\nThe addresses written here must be part of the memory map, have a EfiConventionalMemory type, and page-aligned (4 KBs).\n\nNote: Some types of firmware may not allocate memory areas used by S3 (sleep) and S4 (hibernation) code unless CSM is enabled causing wake failures. After comparing the memory maps with CSM disabled and enabled you could find these areas in the lower memory and fix them up by doing the reservation. Reger to the Sample.plist for details.\n\n2. Comment\nType: plist string\nFailsafe: Empty\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. Whether this value is used is implementation defined.\n3. Size\nType: plist integer\nFailsafe: 0\nDescription: Size of the reserved memory region, must be page-aligned (4 KBs).\n4. Type\nType: plist string\nFailsafe: Reserved\nDescription: Memory region type matching the UEFI specification memory descriptor types. Mapping:\n• Reserved — EfiReservedMemoryType\n• LoaderCode — EfiLoaderCode\n• LoaderData — EfiLoaderData\n• BootServiceCode — EfiBootServicesCode\n• BootServiceData — EfiBootServicesData\n• RuntimeCode — EfiRuntimeServicesCode\n• RuntimeData — EfiRuntimeServicesData\n• Available — EfiConventionalMemory\n• Persistent — EfiPersistentMemory\n• UnusableMemory — EfiUnusableMemory\n• ACPIReclaimMemory — EfiACPIReclaimMemory\n• ACPIMemoryNVS — EfiACPIMemoryNVS\n• MemoryMappedIO — EfiMemoryMappedIO\n• MemoryMappedIOPortSpace — EfiMemoryMappedIOPortSpace\n• PalCode — EfiPalCode\n5. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This region will not be reserved unless set to true.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple User Interface Theme protocol with a builtin version."; ObjectID = "iFT-xW-ZaT"; */
"iFT-xW-ZaT.ibShadowedToolTip" = "Réinstallez le protocole de thème de l'interface utilisateur Apple à l'aide de la version intégrée.";

/* Class = "NSTextFieldCell"; title = "TscSyncTimeout"; ObjectID = "ifT-4Q-EvN"; */
"ifT-4Q-EvN.title" = "TscSyncTimeout";

/* Class = "NSButtonCell"; title = "AppleFramebufferInfo"; ObjectID = "ixW-rs-w20"; */
"ixW-rs-w20.title" = "AppleFramebufferInfo";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Audio codec reconfiguration delay in microseconds.\n\nSome codecs require a vendor-specific delay after the reconfiguration (e.g. volume setting). This option makes it configurable. A typical delay can be up to 0.5 seconds."; ObjectID = "jGE-sP-Rtr"; */
"jGE-sP-Rtr.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 0\nDescription: Audio codec reconfiguration delay in microseconds.\n\nSome codecs require a vendor-specific delay after the reconfiguration (e.g. volume setting). This option makes it configurable. A typical delay can be up to 0.5 seconds.";

/* Class = "NSView"; ibShadowedToolTip = "Type: plist array \nDescription: Designed to be filled with plist dict values, describing memory areas exquisite to particular firmware and hardware functioning, which should not be used by the operating system. An example of such\nmemory region could be second 256 MB corrupted by Intel HD 3000 or an area with faulty RAM. See Reserved-Memory Properties section below."; ObjectID = "k2W-U9-Ysu"; */
"k2W-U9-Ysu.ibShadowedToolTip" = "Type: tableau plist \nDescription: Conçu pour être rempli avec des valeurs dict plist, décrivant les zones de mémoire exquises pour un fonctionnement particulier du firmware et du matériel, qui ne doivent pas être utilisées par le système d'exploitation. Un exemple d'une telle région \nmemory pourrait être un second 256 Mo corrompu par Intel HD 3000 ou une zone avec une RAM défectueuse. Voir la section Propriétés de la mémoire réservée ci-dessous.";

/* Class = "NSTextFieldCell"; title = "Console Mode"; ObjectID = "k5b-42-EPT"; */
"k5b-42-EPT.title" = "Console Mode";

/* Class = "NSButtonCell"; title = "Connect Drivers"; ObjectID = "kBk-75-acl"; */
"kBk-75-acl.title" = "Pilote de connexion";

/* Class = "NSTextFieldCell"; title = "AudioOut"; ObjectID = "kM6-tO-pns"; */
"kM6-tO-pns.title" = "AudioOut";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load APFS drivers for newly connected devices.\n\nPermits APFS USB hot plug which enables loading APFS drivers, both at OpenCore startup and during OpenCore picker dusplay. Disable if not required."; ObjectID = "kSG-eA-B2o"; */
"kSG-eA-B2o.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Load APFS drivers for newly connected devices.\n\nPermits APFS USB hot plug which enables loading APFS drivers, both at OpenCore startup and during OpenCore picker dusplay. Disable if not required.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the OS Info protocol with a builtin version. This protocol is typically used by the firmware and other applications to receive notifications from the macOS bootloader."; ObjectID = "l9b-pk-oii"; */
"l9b-pk-oii.ibShadowedToolTip" = "Forcer la réinstallation du protocole OS Info à l'aide de la version intégrée. Ce protocole est généralement utilisé pour recevoir des notifications du chargeur de démarrage macOS, du micrologiciel ou d'autres applications \n Temporairement inutile, sélectionnez NON.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false \nDescription: Replaces the Apple Framebuffer Info protocol with a builtin version. This may be used to override framebuffer information on VMs or legacy Macs to improve compatibility with legacy EfiBoot such as the one in macOS 10.4."; ObjectID = "lAy-Dr-HPx"; */
"lAy-Dr-HPx.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false \nDescription: Replaces the Apple Framebuffer Info protocol with a builtin version. This may be used to override framebuffer information on VMs or legacy Macs to improve compatibility with legacy EfiBoot such as the one in macOS 10.4.";

/* Class = "NSTableColumn"; headerCell.title = "Address"; ObjectID = "ldi-uY-9wO"; */
"ldi-uY-9wO.headerCell.title" = "Adresse";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty (Maintain current console mode)\nDescription: Sets console output mode as specified with the WxH (e.g. 80x24) formatted string.\n\nSet to Max to attempt using the largest available console mode. This option is currently ignored as the Builtin text renderer only supports one console mode.\n\nNote: This field is best left empty on most types of firmware."; ObjectID = "lye-vu-fi3"; Note = "Do Not Translate"; */
"lye-vu-fi3.ibShadowedToolTip" = "La définition d'une chaîne vide ne modifie pas le mode de la console. Définissez sur Max pour essayer d'utiliser le plus grand mode de console disponible. \n Dans la plupart des cas, laissez-le vide!";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 1\nDescription: Configure pointer speed divisor in OpenCore implementation of Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\nConfigures the divisor for pointer movements. The Apple OEM default value is 1. 0 is an invalid value for this option.\n\nNote: The recommended value for this option is 1. This value may optionally be modified in combination with PointerSpeedMul, according to user preference, to achieve customised mouse movement scaling."; ObjectID = "maU-fq-8kE"; */
"maU-fq-8kE.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 1\nDescription: Configure pointer speed divisor in OpenCore implementation of Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\nConfigures the divisor for pointer movements. The Apple OEM default value is 1. 0 is an invalid value for this option.\n\nNote: The recommended value for this option is 1. This value may optionally be modified in combination with PointerSpeedMul, according to user preference, to achieve customised mouse movement scaling.";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: BuiltinGraphics\nDescription: Chooses renderer for text going through standard console output.\n\nCurrently two renderers are supported: Builtin and System. System renderer uses firmware services for text rendering. Builtin bypassing firmware services and performs text rendering on its own. Different renderers support a different set of options. It is recommended to use Builtin renderer, as it supports HiDPI mode and uses full screen resolution.\n\nUEFI firmware typically supports ConsoleControl with two rendering modes: Graphics and Text. Some types of firmware do not support ConsoleControl and rendering modes. OpenCore and macOS expect text to only be shown in Graphics mode and graphics to be drawn in any mode. Since this is not required by UEFI specification, exact behaviour varies.\n\nValid values are combinations of text renderer and rendering mode:\n• BuiltinGraphics — Switch to Graphics mode and use Builtin renderer with custom ConsoleControl.\n• BuiltinText — Switch to Text mode and use Builtin renderer with custom ConsoleControl.\n• SystemGraphics — Switch to Graphics mode and use System renderer with custom ConsoleControl.\n• SystemText — Switch to Text mode and use System renderer with custom ConsoleControl.\n• SystemGeneric — Use System renderer with system ConsoleControl assuming it behaves correctly.\n\nThe use of BuiltinGraphics is generally straightforward. For most platforms, it is necessary to enable ProvideConsoleGop and set Resolution to Max. The BuiltinText variant is an alternative BuiltinGraphics for some very old and defective laptop firmware, which can only draw in Text mode.\n\nThe use of System protocols is more complicated. Typically, the preferred setting is SystemGraphics or SystemText. Enabling ProvideConsoleGop, setting Resolution to Max, enabling ReplaceTabWithSpace is useful on almost all platforms. SanitiseClearScreen, IgnoreTextInGraphics, and ClearScreenOnModeSwitch are more specific, and their use depends on the firmware.\n\nNote: Some Macs, such as the MacPro5,1, may have incompatible console output when using modern GPUs, and thus only BuiltinGraphics may work for them in such cases. NVIDIA GPUs may require additional firmware upgrades."; ObjectID = "mlh-hW-OqT"; */
"mlh-hW-OqT.ibShadowedToolTip" = "Sélectionnez un rendu pour la sortie de texte via la console standard. \n Deux rendus sont actuellement pris en charge: intégré et système. Le rendu système utilise des services de micrologiciel pour le rendu de texte. La fonction intégrée contourne le service de micrologiciel et effectue le rendu de texte de son propre chef. Différents moteurs de rendu prennent en charge différents ensembles d'options. Il est recommandé d'utiliser le moteur de rendu intégré car il prend en charge le mode HiDPI et utilise une résolution plein écran. \n Le contenu de l'option est une combinaison de rendu de texte et de mode de rendu: \n  • BuiltinGraphics - passez en mode \"graphiques\" et utilisez le rendu intégré avec un ConsoleControl personnalisé. \n  • SystemGraphics-passez en mode \"graphiques\", puis Utilisez le rendu système avec un ConsoleControl personnalisé. \n  • SystemText - basculez en mode texte et utilisez le rendu système avec un ConsoleControl personnalisé. \n  • SystemGeneric - utilisez le rendu système avec le système ConsoleControl et supposez que son comportement est correct. \n BuiltinGraphics est généralement simple à utiliser. Pour la plupart des plates-formes, ProviderConsoleGop doit être activé, définir l'option de résolution sur Max et choisir de configurer Scale. \n L'utilisation des protocoles système est plus compliquée. Habituellement, le paramètre préféré est SystemGraphics ou SystemText. L'activation de ProviderConsoleGop, la définition de «Résolution» sur «Max» et l'activation de «ReplaceTabWithSpace» sont utiles sur presque toutes les plateformes. SanitiseClearScreen, IgnoreTextInGraphics et ClearScreenOnModeSwitch sont plus spécifiques et leur utilisation dépend du firmware. \n  \n Remarque: Certains modèles de Mac, tels que MacPro5,1, peuvent avoir une sortie de console corrompue sur des GPU plus récents, donc seuls BuiltinGraphics fonctionnera pour eux.";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "n2P-We-NTM"; */
"n2P-We-NTM.headerCell.title" = "Activée";

/* Class = "NSButtonCell"; title = "DirectGopRendering"; ObjectID = "nIf-jD-bYP"; */
"nIf-jD-bYP.title" = "DirectGopRendering";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Wraps Firmware Volume protocols or installs a new version to support custom cursor images for FileVault 2. Set to true to ensure FileVault 2 compatibility on anything other than on VMs and legacy Macs.\n\nNote: Several virtual machines, including VMware, may have corrupted cursor images in HiDPI mode and thus, may also require enabling this setting."; ObjectID = "nvr-JF-3ne"; */
"nvr-JF-3ne.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Fixer les problèmes d'interface utilisateur avec Filevault, défini sur OUI pour une meilleure compatibilité avec FileVault";

/* Class = "NSButtonCell"; title = "DeviceProperties"; ObjectID = "oMi-yN-r8X"; */
"oMi-yN-r8X.title" = "DeviceProperties";

/* Class = "NSButtonCell"; title = "AudioSupport"; ObjectID = "oT1-Q2-rhc"; */
"oT1-Q2-rhc.title" = "AudioSupport";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware only clear part of the screen when switching from graphics to text mode, leaving a fragment of previously drawn images visible. This option fills the entire graphics screen with black colour before switching to text mode.\n\nNote: This option only applies to System renderer."; ObjectID = "qMh-AF-g0P"; */
"qMh-AF-g0P.ibShadowedToolTip" = "Lorsque le mode graphique passe en mode texte, certains micrologiciels n'effacent qu'une partie de l'écran, rendant visibles les fragments d'image précédemment dessinés. Cette option remplit tout l'écran graphique de noir avant de passer en mode texte. \n Remarque: cette option fonctionne uniquement avec le rendu système.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forces Resolution to be set in cases where the desired resolution is not available by default, such as on legacy Intel GMA and first generation Intel HD Graphics (Ironlake/Arrandale). Setting Resolution to Max will try to pull the largest available resolution from the connected display’s EDID.\n\nNote: This option depends on the OC_FORCE_RESOLUTION_PROTOCOL protocol being present. This protocol is currently only supported by OpenDuetPkg. The OpenDuetPkg implementation currently only supports Intel iGPUs."; ObjectID = "qSg-5G-J1y"; */
"qSg-5G-J1y.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Forces Resolution to be set in cases where the desired resolution is not available by default, such as on legacy Intel GMA and first generation Intel HD Graphics (Ironlake/Arrandale). Setting Resolution to Max will try to pull the largest available resolution from the connected display’s EDID.\n\nNote: This option depends on the OC_FORCE_RESOLUTION_PROTOCOL protocol being present. This protocol is currently only supported by OpenDuetPkg. The OpenDuetPkg implementation currently only supports Intel iGPUs.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false \nDescription: Replaces the Apple RTC RAM protocol with builtin version.\n\nNote: Builtin version of Apple RTC RAM protocol may filter out I/O attempts to certain RTC memory addresses. \nThe list of addresses can be specified in 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist variable as a data array."; ObjectID = "r1b-ma-oOs"; */
"r1b-ma-oOs.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false \nDescription: Replaces the Apple RTC RAM protocol with builtin version.\n\nNote: Builtin version of Apple RTC RAM protocol may filter out I/O attempts to certain RTC memory addresses. \nThe list of addresses can be specified in 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist variable as a data array.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple boot policy protocol with a builtin version. This may be used to ensure APFS compatibility on VMs or legacy Macs.\n\nNote: This option is advisable on certain Macs, such as the MacPro5,1, that are APFS compatible but on which the Apple Boot Policy protocol has recovery detection issues."; ObjectID = "rMl-Kr-h3I"; */
"rMl-Kr-h3I.ibShadowedToolTip" = "Il est utilisé pour assurer la compatibilité APFS sur les machines virtuelles ou les vieilles pommes blanches. En règle générale, sélectionnez NON.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Multiplication coefficient for system volume to raw volume linear translation from 0 to 1000.\nVolume level range read from SystemAudioVolume varies depending on the codec. To transform read value in [0, 127] range into raw volume range [0, 100] the read value is scaled to VolumeAmplifier percents.\n\nNote: the transformation used in macOS is not linear, but it is very close and this nuance is thus ignored."; ObjectID = "rNr-97-fnH"; */
"rNr-97-fnH.ibShadowedToolTip" = "Un multiple de la conversion linéaire du volume du système au volume d'origine, compris entre 0 et 1000. \n  \n  \n Remarque: Les transformations utilisées dans macOS ne sont pas linéaires, mais sont très proches, donc les nuances sont ignorées.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable keyboard input sanity checking.\nApparently some boards such as the GA Z77P-D3 may return uninitialised data in EFI_INPUT_KEY with all input protocols. This option discards keys that are neither ASCII, nor are defined in the UEFI specification (see tables 107 and 108 in version 2.8)."; ObjectID = "rxJ-TB-rJc"; */
"rxJ-TB-rJc.ibShadowedToolTip" = "Activez le contrôle d'intégrité du clavier.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Implement partial UEFI 2.x support on EFI 1.x firmware.\n\nThis setting allows running some software written for UEFI 2.x firmware like NVIDIA GOP Option ROMs on hardware with older EFI 1.x firmware like MacPro5,1."; ObjectID = "sEw-e9-VYk"; */
"sEw-e9-VYk.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Implement partial UEFI 2.x support on EFI 1.x firmware.\n\nThis setting allows running some software written for UEFI 2.x firmware like NVIDIA GOP Option ROMs on hardware with older EFI 1.x firmware like MacPro5,1.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Key Map protocols with builtin versions."; ObjectID = "tY1-cE-XtN"; */
"tY1-cE-XtN.ibShadowedToolTip" = "Reconstruisez la touche de fonction Apple et sélectionnez NON.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware output text onscreen in both graphics and text mode. This is typically unexpected as random text may appear over graphical images and cause UI corruption. Setting this option to true will discard all text output when console control is in a different mode from Text.\n\nNote: This option only applies to the System renderer."; ObjectID = "tgx-cE-NIf"; */
"tgx-cE-NIf.ibShadowedToolTip" = "Résoudre le problème de l'écrasement du journal de sortie sur le logo Apple lors du démarrage sans -v.";

/* Class = "NSTabViewItem"; label = "Input"; ObjectID = "tiX-oG-c7h"; */
"tiX-oG-c7h.label" = "Entrée";

/* Class = "NSButtonCell"; title = "ClearScreenOnModeSwitch"; ObjectID = "tqx-Ek-u4V"; */
"tqx-Ek-u4V.title" = "ClearScreenOnModeSwitch";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Secure Boot protocol with a builtin version."; ObjectID = "ub5-qQ-fLN"; */
"ub5-qQ-fLN.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Secure Boot protocol with a builtin version.";

/* Class = "NSTableColumn"; headerCell.title = "Size"; ObjectID = "ufL-Er-oh9"; */
"ufL-Er-oh9.headerCell.title" = "Taille";

/* Class = "NSButtonCell"; title = "AppleDebugLog"; ObjectID = "uqk-49-YG8"; */
"uqk-49-YG8.title" = "AppleDebugLog";

/* Class = "NSButtonCell"; title = "UgaPassThrough"; ObjectID = "vav-dM-ieV"; */
"vav-dM-ieV.title" = "UgaPassThrough";

/* Class = "NSTextFieldCell"; title = "PointerSpeedDiv"; ObjectID = "wcl-OF-wk6"; */
"wcl-OF-wk6.title" = "PointerSpeedDiv";

/* Class = "NSTextFieldCell"; title = "ExitBootServicesDelay"; ObjectID = "wxD-TC-lrQ"; */
"wxD-TC-lrQ.title" = "ExitBootServicesDelay";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Treat duplicate key presses as held keys if they arrive during this timeout, in 10 ms units. Only applies to systems using KeySupport.\n\nAppleKeyMapAggregator protocol is supposed to contain a fixed length buffer of currently pressed keys. However, the majority of the drivers which require KeySupport report key presses as interrupts, with automatically generated key repeat behaviour with some defined initial and subsequent delay. As a result, to emulate the raw key behaviour required by several Apple boot systems, we use a timeout to merge multiple repeated keys which are submitted within a small timeout window\n\nThis option allows setting this timeout based on the platform. The recommended value for the majority of platforms is from 5 (50 milliseconds) to 7 (70 milliseconds), although values up to 9 (90 milliseconds) have been observed to be required on some PS/2 systems.For reference, holding a key on VMware will repeat roughly every 20 milliseconds and the equivalent value for APTIO V is 30-40 milliseconds. KeyForgetThreshold should be configured to be longer than this. Thus, it is possible to configure a lower KeyForgetThreshold value on platforms with a faster native driver key repeat rate, for more responsive input, and it is required to set a higher value on slower platforms.\n\nPressing keys one after the other results in delays of at least 60 and 100 milliseconds for the same platforms. Ideally, KeyForgetThreshold should remain lower than this value, to avoid merging real key presses.\n\nTuning the value of KeyForgetThreshold is necessary for accurate and responsive keyboard input on systems on which KeySupport is enabled, and it is recommended to follow the instructions below to tune it correctly for your system.\n\nNote 1: To tune KeyForgetThreshold, you may use the 'set default' indicator within either OpenCanopy or the builtin picker. If KeyForgetThreshold is too low then the 'set default' indicator will continue to flicker while CTRL or =/+ is held down. You should configure the lowest value which avoids this flicker. On some systems (e.g. Aptio IV and potentially other systems using AMI KeySupport mode) you will be able to find a minimum KeyForgetThreshold value at which the 'set default' indicator goes on and stays on with no flicker at all - if so, use this value. On most other systems using KeySupport, you will find that the 'set default' indicator will flicker once, when first pressing and holding the CTRL or =/+ key, and then after a further very brief interval will go on and stay on. On such systems, you should chose the lowest value of KeyForgetThreshold at which you see only one initial flicker and then no subsequent flickering. (Where this happens, it is an unavoidable artefect on those systems of using KeySupport to emulate raw keyboard data, which is not made available by UEFI.)\n\nNote 2: KeyForgetThreshold should never need to be more than about 9 or 10 at most. If it is set to a value much higher than this, it will result in noticeably unresponsive keyboard input. Therefore, for overall key responsiveness, it is strongly recommended to configure a relatively lower value, at which the 'set default' indicator flickers once and then does not flicker, rather than using a much higher value (i.e. significantly greater than 10), which you may be able to find but should not use, where the 'set default' indicator does not flicker at all."; ObjectID = "xNH-9V-3kd"; */
"xNH-9V-3kd.ibShadowedToolTip" = "Intervalle de temps entre chaque touche après l'avoir appuyée (unité: millisecondes) \n Cette option permet de définir ce délai en fonction de votre plateforme. Une valeur recommandée de 5 ms est disponible sur la plupart des plateformes. Pour référence, la détention d'une clé sur VMware se répète toutes les 2 millisecondes environ, tandis que la même valeur pour APTIO V est de 3 à 4 millisecondes. Par conséquent, vous pouvez définir une valeur légèrement inférieure sur une plateforme plus rapide et une valeur légèrement supérieure sur une plateforme plus lente pour améliorer la vitesse de réponse.";

/* Class = "NSButtonCell"; title = "CustomDelays"; ObjectID = "xPB-Sk-c8h"; */
"xPB-Sk-c8h.title" = "CustomDelays";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable custom key repeat delays when using the OpenCore implementation of the Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\n• true — The values of KeyInitialDelay and KeySubsequentDelay are used.\n• false — Apple default values of 500ms (50) and 50ms (5) are used."; ObjectID = "xpZ-sA-YNw"; */
"xpZ-sA-YNw.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Enable custom key repeat delays when using the OpenCore implementation of the Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\n• true — The values of KeyInitialDelay and KeySubsequentDelay are used.\n• false — Apple default values of 500ms (50) and 50ms (5) are used.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Adds delay in microseconds after EXIT_BOOT_SERVICES event.\n\nThis is a very rough workaround to circumvent the Still waiting for root device message on some APTIO IV firmware (ASUS Z87-Pro) particularly when using FileVault 2. It appears that for some reason, they execute code in parallel to EXIT_BOOT_SERVICES, which results in the SATA controller being inaccessible from macOS. A better approach is required and Acidanthera is open to suggestions. Expect 3 to 5 seconds to be adequate when this quirk is needed."; ObjectID = "yXm-Kd-A6O"; */
"yXm-Kd-A6O.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 0\nDescription: Adds delay in microseconds after EXIT_BOOT_SERVICES event.\n\nThis is a very rough workaround to circumvent the Still waiting for root device message on some APTIO IV firmware (ASUS Z87-Pro) particularly when using FileVault 2. It appears that for some reason, they execute code in parallel to EXIT_BOOT_SERVICES, which results in the SATA controller being inaccessible from macOS. A better approach is required and Acidanthera is open to suggestions. Expect 3 to 5 seconds to be adequate when this quirk is needed.";

/* Class = "NSButtonCell"; title = "IgnoreTextInGraphics"; ObjectID = "ygR-oy-xAC"; */
"ygR-oy-xAC.title" = "IgnoreTextInGraphics";

/* Class = "NSButtonCell"; title = "AppleImg4Verification"; ObjectID = "ytA-jO-wqX"; */
"ytA-jO-wqX.title" = "AppleImg4Verification";

/* Class = "NSButtonCell"; title = "ReconnectOnResChange"; ObjectID = "zen-LP-Fan"; */
"zen-LP-Fan.title" = "ReconnectOnResChange";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware block partition handles by opening them in By Driver mode, resulting in an inability to install File System protocols.\n\nNote: This quirk is useful in cases where unsuccessful drive detection results in an absence of boot entries."; ObjectID = "zhZ-UN-ASB"; */
"zhZ-UN-ASB.ibShadowedToolTip" = "Les ordinateurs portables HP sont définis sur OUI lorsqu'il n'y a pas d'entrée de démarrage dans l'interface de démarrage OpenCore";
